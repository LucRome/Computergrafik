# Generating Camera Rays
- means generation of primary rays
- [scratchapixel.com](https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-generating-camera-rays)
- ![](https://www.scratchapixel.com/images/upload/ray-tracing-camera/campixel.gif?)
- Start from the camera (often [0,0,0])
- Film of the Camera is between the camera and the objects
    - By convention often placed exactly 1 unit away from the camera
- Camera is oriented along the negative z-axis (like in OpenGL, Maya, ...)

## Square Image
- assumption: rendered image is a square (simplification)
    - ![](https://www.scratchapixel.com/images/upload/ray-tracing-camera/cambasic.png?)
- Rays are generated by drawing a straight from the camera to the center of each pixel
    - therefore Pixel coordinates which is originally expressed as a **raster space** need to be transformed to world space
    - ![](https://www.scratchapixel.com/images/upload/ray-tracing-camera/cambasic1A.png?)
    - First the Pixel Position is normalized with the frame dimensions -> defined in **NDC space** (Normalised Device coordinates, maps to [0, 1] not like in the rasterization World where it maps to [-1, 1])
    $$
    \begin{array}{ll}
    Pixel_{NDC,x} = \frac{Pixel_x + 0.5}{ImageWidth} \\
    \\
    Pixel_{NDC,y} = \frac{Pixel_y + 0.5}{ImageHeight} \\
    \end{array}
    $$  
    - shift because camera ray should pass through center of the pixel
        - (only here 0.5) normally: $\frac{PixelWidth}{2}$ and ${\frac{PixelHeight}{2}}$
    - then: (to get screen space coordinates)
    $$
    \begin{array}{ll}
    PixelScreen_x = 2 * Pixel_{NDC,x} - 1 \\
    \\
    PixelScreen_y = 1 - 2 * Pixel_{NDC,y} - 1 \\
    \end{array}
    $$

## Image with other aspect ratio
- ![](https://www.scratchapixel.com/images/upload/ray-tracing-camera/camratio.png?)
- with different amounts of pixels on the axis the pixels no longer are squares (need to be made squares again)
$$
\begin{array}{ll}
ImageAspectRatio = \frac{ImageWidth}{ImageHeight} \\
PixelCamera_x = (2 * PixelScreen_x - 1) * ImageAspectRatio \\
PixelCamera_y = (1-2*PixelScreen_y) \\
\end{array}
$$
- x coordinates now range to [-1.4, 1.4]

## Field of View
- previously y Coordinates ranged [-1, 1]
- image plane is 1 unit away from camera origin
- ![](https://www.scratchapixel.com/images/upload/ray-tracing-camera/camprofile.png?)
- $\alpha$ can be computed
    $$ 
    \boxed{ \begin{array}{ll}
        \frac{\alpha}{2} = \arctan{(\frac{OppositeSide}{AdjacentSide})} = \arctan{(\frac{1}{1})} = \frac{\pi}{4} \\
        \\
        ||BC|| = \tan(\frac{\alpha}{2})
    \end{array}}
    $$
- this means pixels can be scaled using $\alpha$ to account for the FOV
    - zooming in: smaller FOV, zooming out: bigger FOV
    $$
    \boxed{ \begin{array}{ll}
        PixelCamera_x = (2 * PixelScreen_x - 1) * ImageAspectRatio * \tan{\frac{\alpha}{2}} \\
        \\
        PixelCamera_y = (1 - 2 * PixelScreen_y) * \tan{\frac{\alpha}{2}}
    \end{array}}
    $$
- Pixels are now in **Camera Space** (same as **World Space** when Camera is at (0,0))
    - Camera is aligned with negative z-Axis, Plane is 1 unit away from camera point
    - Final Point can be expressed as $\boxed{P_{cameraSpace} = (PixelCamera_x, PixelCamera_y, -1)}$
- this gives us a point in the image plane of the camera

## Moving Camera around
- ![](https://www.scratchapixel.com/images/upload/ray-tracing-camera/camtransform.png?)
- Translation and Rotation of the Camera can be expressed using a 4x4 Matrix
    - normally called **camera-to-world matrix** (and inverse is called **world-to-camera matrix**)
    - when camera is applied to to the points O and P we get the Points O' and P'
    - the vector $\vec{O'P'}$ represents the normalized direction of the ray in world space
    - another option would be to first compute $\vec{OP}$ and then apply the camera-to-world matrix to it

## Neccessary Equations
![](https://www.scratchapixel.com/images/upload/ray-tracing-camera/trigosetup.png?)
- u,v,w are the 1st, 2nd and 3rd Vector of the camera-to-world matrix (when using column major)
- d -> direction of the ray (needs to be normalized in the end)
$$
\boxed{\begin{array}{ll}
d = xu + y \cdot (-v) + w\prime \\
with: \\
w\prime = \frac{-width}{2} * u + \frac{height}{2} * v - \frac{height / 2}{\tan{(fov * 0.5)}} * w
\end{array}} \\
$$
- $w\prime$ can be precomputed

## Summary
- We are now able to compute the primary rays
- **Column Major Matrices are used**

# Creating a simple Ray Tracer
- [scratchapixel.com](https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes)

## Parametric and implicit surfaces
### Parametric surfaces
- Parametric Rays: $P=O+tD$
    - ![](https://www.scratchapixel.com/images/upload/ray-simple-shapes/impsurf-ray.png?)
- Spheres:
    - $\begin{array}{ll} P.x=\cos(\theta)\sin(\phi) \\ P.y = \cos(\theta) \\ P.z = \sin(\theta)\sin(\phi)\end{array}$
    - or: $\vec{r}(\theta, \phi) = (\cos(\theta)\sin(\phi), \cos(\theta), \sin(\theta)\sin(\phi)$
    - $0 \leq \theta \leq 2\pi, 0 \leq \phi \leq \pi$
    - ![](https://www.scratchapixel.com/images/upload/ray-simple-shapes/impsurf-sphere.png?)
    - equations may differ depending on used definitions

### Implicit Surfaces
- Sphere: $x^2 + y^2 + z^2 = r^2$
    - although spheres are not really useful for complex shapes, they can be used to test whether a ray intersects with the closer geometry of a complex geometry (bounding volume, saves power)

### Uses
- implicit: check whether ray intersects with object
- parametric: to compute texture coordinates and so on

### Other infos
- the sphere belongs to a category of objects called quadrics (cones, torus, ...)
    - for all quadrics the same solution can be used to test whether they intersect with a ray
- production quality Renderers normally only support one type of object e.g. triangles (other objects are transformed into them)

## Ray-Sphere Intersection
- Two Solutions:
    - Geometric
    - Analytic (can be ported more easily)
### Geometric
- Ray: $\vec{O} + t\vec{D}$
- ![](https://www.scratchapixel.com/images/upload/ray-simple-shapes/raysphereisect1.png?)
- $\begin{array}{ll}P=O+t_0D \\ P'=O+t_1D \\ \end{array}$
- Algorithm:
    1. Compute $t_{ca}$:
        - $\begin{array}{ll} \vec{L}=\vec{C}-\vec{O} \\ \vec{t_{ca}}=\vec{L} \cdot \vec{D} \\ if (t_{ca} < 0) \ return \ false \end{array}$
    2. Compute $d$:
        - $\begin{array}{ll} d = \sqrt{L\cdot L - t_{ca} \cdot t_{ca}} \\ if(d<0\ or\ d>radius)\ return\ false \end{array}$
    3. Compute $t_{hc}$ and $t_0, t_1$:
        - $\begin{array}{ll} t_{hc}=\sqrt{radius^2-d^2} \\ t_0=t_{ca}-t_{hc} \\ t_1=t_{ca}+t_{hc} \end{array}$      
### Analytic Solution
- Sphere can be expressed as $x^2+y^2+z^2=R^2$
    - with $x^2+y^2+z^2=P^2 \rightarrow P^2-R^2 = 0$
    - Point $P$ represents a Point on the surface of the sphere
    - To get the intersect Points the equations for the sphere and the ray must be substituted
    - $\begin{array}{ll} & |O+tD|^2-R^2=0  \\ \rightarrow & O^2+(Dt)^2+2ODt-R^2 \ \widehat{=} \ f(x)=ax^2+bx+c \\ \end{array}$
    - $\boxed{\begin{array}{ll} x = \frac{-b \pm \sqrt{b^2-4ac}}{2a} \\ \Delta = b^2 - 4ac \\ a=D^2, \ b=2OD, \ c=O^2-R^2 \end{array}}$ (Equation 5)
    - $\Delta$ (Discriminant) determines amount of solutions (intersect points):
      - $\Delta > 0$:
        - $x_1=\frac{-b+\sqrt{\Delta}}{2a}\ and\ x_2=\frac{-b-\sqrt{\Delta}}{2a}$
      - $\Delta = 0$:
        - $x=-\frac{b}{2a}$
      - $\Delta < 0$:
        - No solution $\rightarrow$ No intersect Point

- For a Sphere thats not centered at the Origin:
  - New Sphere Equation: $|P-C|^2 - R^2 = 0,\ C: Offset$
  - $\rightarrow \ |O+tD-C|^2-R^2=0$
  - **new a,b,c:**
    - $\boxed{\begin{array}{ll} a=D^2 \ (1\ when\ normalised) \\ b=2D(O-C) \\ c=|O-C|^2-R^2 \end{array}}$

- Improvements for Computers:
  - Equation 5 is not suitable, since computers have limited accuracy -> may lead to errors
  - Instead: $\boxed{\begin{array}{ll} q=-\frac{1}{2}(b+sign(b)\sqrt{b^2-4ac}) \\ x_1=\frac{q}{a} \\ x_2=\frac{c}{q} \end{array}}$
    - $\boxed{sign(x) = \left\{\begin{array}{ll} -1 & for & b<0 \\ 1 & otherwise\end{array}\right.}$
  - When there are multiple objects one needs to keep track of the closest object
### Compute Intersect Point:
- $t_0$: Parameter t for the visible intersect Point
  - $P_{hit}=O+t_0D$
- Different Possibilities for Intersect Points:
  - ![](https://www.scratchapixel.com/images/upload/ray-simple-shapes/rayspherecases.png?)

### Computing the Normal at Intersection Point
- ![](https://www.scratchapixel.com/images/upload/ray-simple-shapes/impsurf-normal.png?)
- $N=||P_{hit}-C||$ (||a||: Vector a normalised)

### Computing Texture Coordinates
- Irrelevant here

## Ray-Plane and Ray-Disk intersection
### Ray-Plane Intersection
- ![](https://www.scratchapixel.com/images/upload/ray-simple-shapes/plane.png?)
- Plane has the form: $(p-p_0) \cdot n = 0$
- Ray: $l_0+l\cdot t=p$ ($l_0$: Origin, $l$: Direction, $t$: Parameter)
- By inserting the ray Equation into the Plane Equation we get: $t=\frac{(p_0-l_0) \cdot n}{l \cdot n}$
  - NÃ¤herung: $l \cdot n < 1e-6 \rightarrow$ nearly parrallel $\rightarrow$ no Intersection Point

### Ray-Disk Intersection
- ![](https://www.scratchapixel.com/images/upload/ray-simple-shapes/disk.png?)
- like Ray-Plane
- Additional condition:
  - $|{p-p_0}| <= radius$ or optimised ($r^2$ can be precomputed, no sqrt): $(p-p_0)^2 <= radius^2$

## Ray-Box Intersection:
- TODO

# Common Coordinate Systems
- [scratchapixel.com](https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-generating-camera-rays/standard-coordinate-systems)